Table variables set operators

Set operators: union, intersect, except

e.g. If we want to find all pairs of students who have the same GPA => we need 2 instances of Student table.

SELECT *
FROM Student S1, Student S2
WHERE S1.GPA = S2.GPA        /*explitic join required in SQL */
AND S1.sID < S2.sID;         /*so we do not match the same person - we want distinct. List the one with the smallest sID first */


e.g. We want all ID of students who applied for major CS and EE

SELECT DISTINCT A1.sID
FROM Apply A1, Apply A2
WHERE A1.sID = A2.sID                     /* make sure they are the same student */
AND A1.major = 'CS' AND A2.major = 'EE';  /* one case they applied CS, another case they applied EE */


e.g. Find all sID of students who applied major CS BUT NOT major EE

SELECT sID FROM Apply WHERE major = 'CS'
EXCEPT
SELECT sID FROM Apply WHERE major = 'EE';

SELECT DISTINCT A1.sID 
FROM Apply A1, Apply A2
WHERE A1.major = 'CS'
AND A2.major <> 'EE';

-----------------------------------------------------------------------------------------------------------
Subqueries in WHERE clause


e.g Find IDs and names of all students who applied to major in CS at some college (2 methods):

method 1: subquery

SELECT sID, sName
FROM Student
WHERE Student.sID IN (        /* WHERE _____ IN is the subquery intro */
    SELECT sID 
    FROM Apply
    WHERE major = 'CS'
);
    
method 2: JOIN

SELECT DISTINCT Student.sID, sName
FROM Student, Apply
WHERE Student.sID = Apply.sID 
AND Apply.major = 'CS';


/* Why do we care about duplicates? E.g. If we have two Craigs (sName) but they are different people sID are different.
If we SELECT DISTINCT on sID, both Craigs will show up, but if we SELECT DISTINCT on sName, only one Craig will show up). */

/* E.g. duplicates are important: average GPA of CS applicants */

SELECT GPA
FROM Student
WHERE Student.sID IN (
    SELECT Apply.sID
    FROM Apply
    WHERE major = 'CS');
    
/* e.g. find students who applied to major CS but not to major EE */

SELECT sID, sName
FROM Student                  /* looks for a student
WHERE Student.sID IN (        /* where the student ID is among the set of ID
    SELECT sID                    of students who applied to CS
    FROM Apply
    WHERE major = 'CS')
AND Student.sID NOT IN (      /* but student ID is NOT among the set of ID 
    SELECT sID                  of students who applied to EE
    FROM Apply
    Where major = 'EE');

or we can write

SELECT sID, sName
FROM Student                  
WHERE Student.sID IN (        
    SELECT sID                    
    FROM Apply
    WHERE major = 'CS')
AND NOT Student.sID IN (      /* AND NOT Student.sID IN instead of AND Student.sID NOT IN
    SELECT sID                 
    FROM Apply
    Where major = 'EE');
    
e.g. Find all colleges such that there are some other college in the same state - return name and state

SELECT cName, state
FROM College C1
WHERE EXISTS(                                  /* for each college, check does it exist another college C2 where the state of C1 = C2 */
    SELECT *
    FROM College C2
    WHERE C2.state = C1.state AND C1.cName <> C2.cName);

/* This is known as a correlated substance: inside the subquery, we are going to refer to a value C1 that comes from outside the subquery */


e.g. Finding the college with the largest enrollment (without using MAX) - return college name

SELECT cname
FROM College C1
WHERE NOT EXISTS (
SELECT * FROM College C2
  WHERE C2.enrollment > C1.enrollment); /*find all college where it does not exist another college whose enrolment is higher than the one we are returning

SQLite does not support ANY. Can always replace ANY with EXISTS or NOT EXISTS.
Exists test for existence of record. Returns true if it exists.

e.g. Find students not from the smallest high school *CONFUSING

SELECT sID, sName, sizeHS
FROM Student S1
WHERE EXISTS (                      /*look for a student, where there exists
    SELECT * FROM Student S2        /*some other student S2 whose HS is smaller than the student we return
    WHERE S2.sizeHS < S1.sizeHS); 
    
------------------------------------------------------------------
Subqueries in FROM and SELECT clauses

Above, we used subqueries in the WHERE = condition for comparison

Can use subqueries in:

SELECT  - writing a sub-select expression that produces the value that comes out of the query
FROM    - running a nested select stmt that is going to generate one of the table that we will use in the rest of the query

/* e.g. return all students whose scaled GPA changes GPA by more than 1 */

SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student
WHERE GPA*(sizeHS/1000.0) - GPA > 1.0
OR
GPA - GPA*(sizeHS/1000.0) > 1.0;

to simplify:

SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student
WHERE abs(GPA*(sizeHS/1000.0) - GPA) > 1.0;

to simplify further: put subquery in FROM clause. Create a select from where
that produces a relation, and the rest of the query can treat that just
as a relation so we can refer to it.

SELECT *
FROM (SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student) G                                                /*turn it into its own subquery and put it in FROM clause and call it G
WHERE abs(G.scaled GPA - GPA) > 1.0;

/* this says compute the from where expression and call the result G 
and now in the rest of the query, anytime I refer to G, I refer to the 
result of the subquery in the FROM. Specifically, I now have scaled GPA.
And I can use that scaled GPA in the rest of my query.*/


/* subquery in the select clause */ HARD

/*Find colleges and pair those colleges with the highest GPA of their applicants.
Return college name, state and GPA of students.*/

SELECT DISTINCT College.cName, College.state, Student.GPA
FROM College, Apply, Student 
WHERE College.cName = Apply.cName
AND Apply.sID = Student.sID
AND GPA >= ALL (                  */where GPA is the highest among the GPAs of the students who applied to that same college
    SELECT Student.GPA 
    FROM Student, Apply
    WHERE Student.sID = Apply.sID
    AND Apply.cName = College.cName);

/* The ANY operator returns true if any of the subquery values meet the condition.
The ALL operator returns true if all of the subquery values meet the condition. */

/*Now lets re-write this query using a sub-query in the SELECT clause 
What a subquery in a SELECT clause does is performs a computation and as long as the computation returns exactly one value, that value
is used in the result tuple.
*/

HARD

SELECT cName, state,(
    SELECT DISTINCT GPA
    FROM Apply, Student
    WHERE College.cName = Apply.cName
        AND Apply.sID = Student.sID
        AND GPA >= ALL (
            SELECT GPA FROM Student, Apply
            WHERE Student.sID = Apply.sID
                AND Apply.cName = College.cName)) AS GPA
FROM College;

*Seems like SQLiteStudio cannot perform ALL function. Maybe we can use ANY

/* Instead of pairing every college with the highest GPA of the applicants, we want to pair college
with names of the applicants */

SELECT cName, state,(
    SELECT DISTINCT sName
    FROM Apply, Student
    WHERE College.cName = Apply.cName
        AND Apply.sID = Student.sID) AS sName
FROM College;

-> ERROR: the SELECT subquery did not return exactly one result. In this case
we have several students apply to colleges, so wouldn't know when we have a bunch of values
which one to put in the tuple being constructed. 

ERROR message says: Subquery returns more than 1 row.

--------------------------------------------------------------------------------------------------------
The JOIN family of operators 

We have implicit and also explicit JOIN tables.

- Inner Join on condition
- Natural join (eliminates duplicates columns created)
- Inner join USING (attrs) 
- Left | Right | Full Outer Join

Using comma to join is a cross product

e.g. SELECT * 
     FROM Apply, Student, College

Natural join example:
SELECT DISTINCT sName, major
FROM Student, Apply
WHERE Student.sID = Apply.sID;

Theta join (inner join) example:

SELECT DISTINCT sName, major
FROM Student INNER JOIN Apply       /*JOIN is an abbreviation for INNER JOIN - can delete INNER */
ON Student.sID = Apply.sID          /*Use JOIN ON instead of WHERE */


e.g. Find name and GPA of student whose HS is less than 1000, major is in CS and went to Stanford

SELECT sName, GPA
FROM Student JOIN Apply
ON Student.sID = Apply.sID
AND sizeHS < 1000 AND major = 'CS' AND cName 'Stanford';


*When do we use WHEN or AND?

AND condition - if we put all the conditions "AND sizeHS < 1000 AND major = 'CS' AND cName 'Stanford'"
in the ON condition, we are saying, as the query processor does the JOIN,
it should be applying all the conditions. 

WHERE condition - says, here's the condition that really applies to the combination of the tuples
and the rest of the conditions apply to the separate attributes.

e.g. Find a bunch of information about student applications. Join all three of our tables.

SELECT Apply.sID, sName, GPA, Apply.cName, enrollment
FROM Apply JOIN Student JOIN College
ON Apply.sID = Student.sID AND Apply.cName = College.cName;


With postgresql (cannot do 3 way join):

SELECT Apply.sID, sName, GPA, Apply.cName, enrollment
FROM (Apply JOIN Student ON Apply.sID = Student.sID) JOIN College        /*postgresql does not allow 3 way joins, otherwise can just do JOIN JOIN */
ON Apply.cName = College.cName;

Interaction between expression of a query in SQL and the query processor

SQL systems do tend to actually follow the structure that is provided when we have join operators and we parenthesize them
People do tune SQL to enhance performance by changing order around.


*Natural join takes two relations that have column names in common and performs a 
cross product that only keeps the tuples that have the same value in those
common attribute names.

e.g. 
SELECT DISTINCT sName, major
FROM Student NATURAL JOIN Apply;

is the same as:

SELECT DISTINCT sName, major
FROM Student INNER JOIN Apply
ON Student.sID = Apply.sID;


e.g.

SELECT sName, GPA
FROM Student NATURAL JOIN Apply
WHERE sizeHS < 1000 AND major = 'CS' and cName = 'Stanford';


e.g. 
There a feature in SQL that is considered better practice than using the natural join
and it's called the USING clause.

USING - explicitly lists the attributes that should be equated across the relations.

SELECT sName, GPA
FROM Student JOIN Apply USING(sID)          /* we can only use the USING clause on attributes that appear in both relations */
WHERE sizeHS < 1000 AND major = 'CS' and cName = 'Stanford';


e.g. Combine two instances of the student relation in order to find paris of students that have same GPA

SELECT S1.sID, S1.sName, S1.GPA, S2.SID, S2.sName, S2.GPA
FROM Student S1 JOIN Student S2 USING(GPA)
WHERE S1.sID < S2.sID               /*most SQL systems do not allow you to use USING and JOIN ON */

e.g. Get the Student relation

SELECT * 
FROM Student S1 natural JOIN Student S2;

e.g. Outer join

e.g. Information about students who have not applied anywhere yet

SELECT sName, sID, cName, major
FROM Student LEFT JOIN Apply using(sID); /* LEFT JOIN = LEFT OUTER JOIN */

SELECT sName, sID, cName, major
FROM Student NATURAL LEFT JOIN Apply; /*implicitly (or natural) join Student with Apply on sID - not recommended */


e.g. Can re-write the outer join without using outer join

SELECT sName, Student.sID, cName, major
FROM Student, Apply                 /*inner join of Student and Apply so all tuples matches*/
WHERE Student.sID = Apply.sID       /*cross product form */
UNION                               /*add to that result - union of the result
SELECT sName, sID, NULL, NULL       /* return sName, sID, NULL and NULL
FROM Student                        /*Student tuple
WHERE sID NOT IN (                  /*that don't have a matching tuple in Apply
    SELECT sID                      /*sID that does not appear in the Apply
    FROM Apply
);

e.g. RIGHT OUTER JOIN:

SELECT sName, sID, cName, major
FROM Student NATURAL RIGHT OUTER JOIN Apply;

e.g. Unmatched tuples from both LEFT AND RIGHT in our result (full outer join):

SELECT sName, sID, cName, major
FROM Student FULL OUTER JOIN Apply USING(sID);

e.g. Can express full outer join using combination of left and right outer join:

SELECT sName, sID, cName, major
FROM Student LEFT OUTER JOIN Apply USING(sID)
UNION                                           /* UNION auto removes duplicates */
SELECT sName, sID, cName, major
FROM Student RIGHT OUTER JOIN Apply USING(sID)

e.g. Can simulate without using any JOINs at all - 3 parts:

SELECT sName, Student.sID, cName, major
FROM Student, Apply                     /*find all of the matching student and apply records
WHERE Student.sID = Apply.sID
UNION
SELECT sName, sID, NULL, NULL
FROM Student                             /*adds those students who are not in apply
WHERE sID NOT IN (SELECT sID FROM Apply)
UNION
SELECT NULL, sID, cName, major      
FROM Apply
WHERE sID NOT IN (SELECT sID FROM Student); /*find those apply records where there's not a matching student */


e.g.
Commutativity (A op B) = (B op A)       /*most joins are like that except left and right outer join
Associativity (A op B) op C = A op (B op C)         /*can do in any order first - OUTER JOIN is not associative 

-----------------------------------------------------------------
Aggregation








