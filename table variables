Table variables set operators

Set operators: union, intersect, except

e.g. If we want to find all pairs of students who have the same GPA => we need 2 instances of Student table.

SELECT *
FROM Student S1, Student S2
WHERE S1.GPA = S2.GPA        /*explitic join required in SQL */
AND S1.sID < S2.sID;         /*so we do not match the same person - we want distinct. List the one with the smallest sID first */


e.g. We want all ID of students who applied for major CS and EE

SELECT DISTINCT A1.sID
FROM Apply A1, Apply A2
WHERE A1.sID = A2.sID                     /* make sure they are the same student */
AND A1.major = 'CS' AND A2.major = 'EE';  /* one case they applied CS, another case they applied EE */


e.g. Find all sID of students who applied major CS BUT NOT major EE

SELECT sID FROM Apply WHERE major = 'CS'
EXCEPT
SELECT sID FROM Apply WHERE major = 'EE';

SELECT DISTINCT A1.sID 
FROM Apply A1, Apply A2
WHERE A1.major = 'CS'
AND A2.major <> 'EE';

-----------------------------------------------------------------------------------------------------------
Subqueries in WHERE clause


e.g Find IDs and names of all students who applied to major in CS at some college (2 methods):

method 1: subquery

SELECT sID, sName
FROM Student
WHERE Student.sID IN (        /* WHERE _____ IN is the subquery intro */
    SELECT sID 
    FROM Apply
    WHERE major = 'CS'
);
    
method 2: JOIN

SELECT DISTINCT Student.sID, sName
FROM Student, Apply
WHERE Student.sID = Apply.sID 
AND Apply.major = 'CS';


/* Why do we care about duplicates? E.g. If we have two Craigs (sName) but they are different people sID are different.
If we SELECT DISTINCT on sID, both Craigs will show up, but if we SELECT DISTINCT on sName, only one Craig will show up). */

/* E.g. duplicates are important: average GPA of CS applicants */

SELECT GPA
FROM Student
WHERE Student.sID IN (
    SELECT Apply.sID
    FROM Apply
    WHERE major = 'CS');
    
/* e.g. find students who applied to major CS but not to major EE */

SELECT sID, sName
FROM Student                  /* looks for a student
WHERE Student.sID IN (        /* where the student ID is among the set of ID
    SELECT sID                    of students who applied to CS
    FROM Apply
    WHERE major = 'CS')
AND Student.sID NOT IN (      /* but student ID is NOT among the set of ID 
    SELECT sID                  of students who applied to EE
    FROM Apply
    Where major = 'EE');

or we can write

SELECT sID, sName
FROM Student                  
WHERE Student.sID IN (        
    SELECT sID                    
    FROM Apply
    WHERE major = 'CS')
AND NOT Student.sID IN (      /* AND NOT Student.sID IN instead of AND Student.sID NOT IN
    SELECT sID                 
    FROM Apply
    Where major = 'EE');
    
e.g. Find all colleges such that there are some other college in the same state - return name and state

SELECT cName, state
FROM College C1
WHERE EXISTS(                                  /* for each college, check does it exist another college C2 where the state of C1 = C2 */
    SELECT *
    FROM College C2
    WHERE C2.state = C1.state AND C1.cName <> C2.cName);

/* This is known as a correlated substance: inside the subquery, we are going to refer to a value C1 that comes from outside the subquery */


e.g. Finding the college with the largest enrollment (without using MAX) - return college name

SELECT cname
FROM College C1
WHERE NOT EXISTS (
SELECT * FROM College C2
  WHERE C2.enrollment > C1.enrollment); /*find all college where it does not exist another college whose enrolment is higher than the one we are returning

SQLite does not support ANY. Can always replace ANY with EXISTS or NOT EXISTS.
Exists test for existence of record. Returns true if it exists.

e.g. Find students not from the smallest high school *CONFUSING

SELECT sID, sName, sizeHS
FROM Student S1
WHERE EXISTS (                      /*look for a student, where there exists
    SELECT * FROM Student S2        /*some other student S2 whose HS is smaller than the student we return
    WHERE S2.sizeHS < S1.sizeHS); 
    
------------------------------------------------------------------
Subqueries in FROM and SELECT clauses

Above, we used subqueries in the WHERE = condition for comparison

Can use subqueries in:

SELECT  - writing a sub-select expression that produces the value that comes out of the query
FROM    - running a nested select stmt that is going to generate one of the table that we will use in the rest of the query

/* e.g. return all students whose scaled GPA changes GPA by more than 1 */

SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student
WHERE GPA*(sizeHS/1000.0) - GPA > 1.0
OR
GPA - GPA*(sizeHS/1000.0) > 1.0;

to simplify:

SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student
WHERE abs(GPA*(sizeHS/1000.0) - GPA) > 1.0;

to simplify further: put subquery in FROM clause. Create a select from where
that produces a relation, and the rest of the query can treat that just
as a relation so we can refer to it.

SELECT *
FROM (SELECT sID, sName, GPA, GPA*(sizeHS/1000.0) AS scaledGPA
FROM Student) G                                                /*turn it into its own subquery and put it in FROM clause and call it G
WHERE abs(G.scaled GPA - GPA) > 1.0;

/* this says compute the from where expression and call the result G 
and now in the rest of the query, anytime I refer to G, I refer to the 
result of the subquery in the FROM. Specifically, I now have scaled GPA.
And I can use that scaled GPA in the rest of my query.*/


/* subquery in the select clause */ HARD

/*Find colleges and pair those colleges with the highest GPA of their applicants.
Return college name, state and GPA of students.*/

SELECT DISTINCT College.cName, College.state, Student.GPA
FROM College, Apply, Student 
WHERE College.cName = Apply.cName
AND Apply.sID = Student.sID
AND GPA >= ALL (                  */where GPA is the highest among the GPAs of the students who applied to that same college
    SELECT Student.GPA 
    FROM Student, Apply
    WHERE Student.sID = Apply.sID
    AND Apply.cName = College.cName);

/* The ANY operator returns true if any of the subquery values meet the condition.
The ALL operator returns true if all of the subquery values meet the condition. */

/*Now lets re-write this query using a sub-query in the SELECT clause 
What a subquery in a SELECT clause does is performs a computation and as long as the computation returns exactly one value, that value
is used in the result tuple.
*/

HARD

SELECT cName, state,(
    SELECT DISTINCT GPA
    FROM Apply, Student
    WHERE College.cName = Apply.cName
        AND Apply.sID = Student.sID
        AND GPA >= ALL (
            SELECT GPA FROM Student, Apply
            WHERE Student.sID = Apply.sID
                AND Apply.cName = College.cName)) AS GPA
FROM College;

*Seems like SQLiteStudio cannot perform ALL function. Maybe we can use ANY

/* Instead of pairing every college with the highest GPA of the applicants, we want to pair college
with names of the applicants */

SELECT cName, state,(
    SELECT DISTINCT sName
    FROM Apply, Student
    WHERE College.cName = Apply.cName
        AND Apply.sID = Student.sID) AS sName
FROM College;

-> ERROR: the SELECT subquery did not return exactly one result. In this case
we have several students apply to colleges, so wouldn't know when we have a bunch of values
which one to put in the tuple being constructed. 

ERROR message says: Subquery returns more than 1 row.

--------------------------------------------------------------------------------------------------------
The JOIN family of operators 

We have implicit and also explicit JOIN tables.

- Inner Join on condition
- Natural join (eliminates duplicates columns created)
- Inner join USING (attrs) 
- Left | Right | Full Outer Join

Using comma to join is a cross product

e.g. SELECT * 
     FROM Apply, Student, College

Natural join example:
SELECT DISTINCT sName, major
FROM Student, Apply
WHERE Student.sID = Apply.sID;

Theta join (inner join) example:

SELECT DISTINCT sName, major
FROM Student INNER JOIN Apply       /*JOIN is an abbreviation for INNER JOIN - can delete INNER */
ON Student.sID = Apply.sID          /*Use JOIN ON instead of WHERE */


e.g. Find name and GPA of student whose HS is less than 1000, major is in CS and went to Stanford

SELECT sName, GPA
FROM Student JOIN Apply
ON Student.sID = Apply.sID
AND sizeHS < 1000 AND major = 'CS' AND cName 'Stanford';


*When do we use WHEN or AND?

AND condition - if we put all the conditions "AND sizeHS < 1000 AND major = 'CS' AND cName 'Stanford'"
in the ON condition, we are saying, as the query processor does the JOIN,
it should be applying all the conditions. 

WHERE condition - says, here's the condition that really applies to the combination of the tuples
and the rest of the conditions apply to the separate attributes.

e.g. Find a bunch of information about student applications. Join all three of our tables.

SELECT Apply.sID, sName, GPA, Apply.cName, enrollment
FROM Apply JOIN Student JOIN College
ON Apply.sID = Student.sID AND Apply.cName = College.cName;


With postgresql (cannot do 3 way join):

SELECT Apply.sID, sName, GPA, Apply.cName, enrollment
FROM (Apply JOIN Student ON Apply.sID = Student.sID) JOIN College        /*postgresql does not allow 3 way joins, otherwise can just do JOIN JOIN */
ON Apply.cName = College.cName;

Interaction between expression of a query in SQL and the query processor

SQL systems do tend to actually follow the structure that is provided when we have join operators and we parenthesize them
People do tune SQL to enhance performance by changing order around.


*Natural join takes two relations that have column names in common and performs a 
cross product that only keeps the tuples that have the same value in those
common attribute names.

e.g. 
SELECT DISTINCT sName, major
FROM Student NATURAL JOIN Apply;

is the same as:

SELECT DISTINCT sName, major
FROM Student INNER JOIN Apply
ON Student.sID = Apply.sID;


e.g.

SELECT sName, GPA
FROM Student NATURAL JOIN Apply
WHERE sizeHS < 1000 AND major = 'CS' and cName = 'Stanford';


e.g. 
There a feature in SQL that is considered better practice than using the natural join
and it's called the USING clause.

USING - explicitly lists the attributes that should be equated across the relations.

SELECT sName, GPA
FROM Student JOIN Apply USING(sID)          /* we can only use the USING clause on attributes that appear in both relations */
WHERE sizeHS < 1000 AND major = 'CS' and cName = 'Stanford';


e.g. Combine two instances of the student relation in order to find paris of students that have same GPA

SELECT S1.sID, S1.sName, S1.GPA, S2.SID, S2.sName, S2.GPA
FROM Student S1 JOIN Student S2 USING(GPA)
WHERE S1.sID < S2.sID               /*most SQL systems do not allow you to use USING and JOIN ON */

e.g. Get the Student relation

SELECT * 
FROM Student S1 natural JOIN Student S2;

e.g. Outer join

e.g. Information about students who have not applied anywhere yet

SELECT sName, sID, cName, major
FROM Student LEFT JOIN Apply using(sID); /* LEFT JOIN = LEFT OUTER JOIN */

SELECT sName, sID, cName, major
FROM Student NATURAL LEFT JOIN Apply; /*implicitly (or natural) join Student with Apply on sID - not recommended */


e.g. Can re-write the outer join without using outer join

SELECT sName, Student.sID, cName, major
FROM Student, Apply                 /*inner join of Student and Apply so all tuples matches*/
WHERE Student.sID = Apply.sID       /*cross product form */
UNION                               /*add to that result - union of the result
SELECT sName, sID, NULL, NULL       /* return sName, sID, NULL and NULL
FROM Student                        /*Student tuple
WHERE sID NOT IN (                  /*that don't have a matching tuple in Apply
    SELECT sID                      /*sID that does not appear in the Apply
    FROM Apply
);

e.g. RIGHT OUTER JOIN:

SELECT sName, sID, cName, major
FROM Student NATURAL RIGHT OUTER JOIN Apply;

e.g. Unmatched tuples from both LEFT AND RIGHT in our result (full outer join):

SELECT sName, sID, cName, major
FROM Student FULL OUTER JOIN Apply USING(sID);

e.g. Can express full outer join using combination of left and right outer join:

SELECT sName, sID, cName, major
FROM Student LEFT OUTER JOIN Apply USING(sID)
UNION                                           /* UNION auto removes duplicates */
SELECT sName, sID, cName, major
FROM Student RIGHT OUTER JOIN Apply USING(sID)

e.g. Can simulate without using any JOINs at all - 3 parts:

SELECT sName, Student.sID, cName, major
FROM Student, Apply                     /*find all of the matching student and apply records
WHERE Student.sID = Apply.sID
UNION
SELECT sName, sID, NULL, NULL
FROM Student                             /*adds those students who are not in apply
WHERE sID NOT IN (SELECT sID FROM Apply)
UNION
SELECT NULL, sID, cName, major      
FROM Apply
WHERE sID NOT IN (SELECT sID FROM Student); /*find those apply records where there's not a matching student */


e.g.
Commutativity (A op B) = (B op A)       /*most joins are like that except left and right outer join
Associativity (A op B) op C = A op (B op C)         /*can do in any order first - OUTER JOIN is not associative 

-----------------------------------------------------------------
Aggregation

Agg performs computations over sets of values in multiple rows of a relation.

MIN, AMX, SUM, AVG, COUNT

appear in SELECT clause initially. 

GROUP BY columns 
HAVING conditions - test filters on results of aggregate values - apply to groups that we gwenerate from GROUP BY clause

e.g. 

SELECT AVG(GPA)
FROM Student;

e.g. Find min GPA of students who applied in CS

SELECT MIN(GPA)
FROM Student, Apply
WHERE Student.sID = Apply.sID AND major = 'CS';

*do not want to count GPA twice if a student applied to CS 2+ at different schools
presumably, we want to only count each student's GPA once no matter how many times they applied

Use subquery form instead.

Lets see how many students applied to CS first:

1st:
SELECT *
FROM Student
WHERE sID IN(
    SELECT sID 
    FROM Apply
    WHERE major = 'CS'
);

Lets take the average GPA second:

2nd:
SELECT AVG(GPA)
FROM Student
WHERE sID IN(
    SELECT sID
    FROM Apply
    WHERE major = 'CS'
);

e.g. COUNT function - returns the number of tuples in the result

1st - run it without the aggregate function - we see there are 2:

SELECT *
FROM College
WHERE enrollment > 15000;

SELECT COUNT(*)
FROM College
WHERE enrollment > 15000;

e.g. find number of students who have applied to Cornell

SELECT COUNT (*)
FROM Apply
WHERE cName = 'Cornell';

*we actually jsut counted the number of applications to Cornell.
If a student applied 3 times, we are counting it 3 times in the result.

SELECT COUNT (DISTINCT sID)
FROM Apply
WHERE cName = 'Cornell';

*this returns 3 distinct student IDs - COUNT DISTINCT is very useful

e.g. Gives us all students such that number of other students with same GPA
is equal to number of other students with same sizeHS

SELECT *
FROM Student S1     /*looks at student relation
WHERE (SELECT COUNT (*) FROM Student S2     /*for each student, count number of other students in S2 by testing ID is different, that have same GPA 
       WHERE S2.sID <> S1.sID AND S2.GPA = S1.GPA) =
      (SELECT COUNT(*) FROM Student S2      /*also counts the number of other students that have same size HS and if thsoe two values  
       WHERE S2.sID <> S1.sID AND S2.sizeHS = S1.sizeHS);

*both subqueries produce a single value, which is why we can test equality


e.g. computer amount by which average GPA of students applying to CS 
exceeds the average GPA of students NOT applying to CS - seems hard

SELECT CS.avgGPA - nonCS.avgGPA
FROM (            /*subquery in the FROM clause - allows you to write a SELECT FROM WHERE expression and use the result of the expression as if it were an actual table in the database    
        SELECT AVG(GPA) as avgGPA
        FROM Student
        WHERE sID IN (                /*find the students who have applied to major in CS, computer their average GPA and call it avgGPA. We'll take the whole result and name it CS.
                        SELECT sID
                        FROM Apply WHERE major = 'CS')) AS CS,
      (
        SELECT AVG(GPA) as avgGPA   /*computer avgGPA of students who did not apply to CS (NOT IN) the set of students who applied to CS. And we'll call that one nonCS 
        FROM Student
        WHERE sID NOT IN(
                          SELECT sID 
                           FROM Apply WHERE major = 'CS)) AS nonCS;

*computer 2 subquery in the FROM clause. One of them is the avgGPA of CS applicant, and one of them is avgGPA of non CS applicant
*now with this FROM clause, we have a relation call CS with an attribute called average GPA and a relation
called non CS with an attribute called average GPA. And in the SELECT clause, we'll just subtract it.

*we can re-write this with the subquery in the SELECT clause. In the SELECT clause,
we can write a subquery as long as it returns a single value.

SELECT DISTINCT(
    SELECT avg(GPA) as avgGPA       /*average GPA of CS student in SELECT clause producing a value
    FROM Student
    WHERE sID IN(
        SELECT sID
        FROM Apply
        WHERE major = 'CS')) -
    (SELECT avg(GPA) as avgGPA FROM Student     /*avg GPA of NON CS student 
     WHERE sID NOT IN(
        SELECT sID FROM Apply WHERE major = 'CS')) AS d   /*call the result of the subtraction as d for difference
FROM Student;
        
*perform subtraction as part of the SELECT clause 
- reason for duplicates is because we computed this result once for each tuple in Student.

GROUP BY clause - only use in conjunction with aggregation

takes a relationa nd partitions it by value

e.g. find number of applications to each college

SELECT cName, COUNT(*)
FROM Apply          /*taking apply relations and breaking into groups where each group has one of the college names (e.g. Stanford, Berkeley) and for each group will return one tuple in the result
GROUP BY cName;


e.g. find total enrollment of college students for each state

SELECT state, SUM(enrollment)
FROM College                /*takes college relation and breaks it by state and then within each group, return state for that partition and suim of the enrollment 
GROUP BY state;

e.g. for each college and major combination, the min and amx GPAs for the student who have applied to that college

SELECT cName, major, MIN(GPA), MAX(GPA)
FROM Student, Apply
WHERE Student.sID = Apply.sID
GROUP BY cName, major;

e.g. find diff between min and max of GPA (spread) or find largest spread 

SELECT MAX(mx-mn)
FROM (SELECT cName, major, MIN(GPA) AS mn, MAX(GPA) AS mx
      FROM Student, Apply
      WHERE Student.sID = Apply.sID
      GROUP BY cName, major) M;

e.g. this example is to show subtleties of the group by clause 
query finds the number of colleges that have been applied to by each student.

SELECT Student.sID, sName, COUNT(DISTINCT cNAME)
FROM Student, Apply
WHERE Student.sID = Apply.sID
GROUP BY Student.sID

*if we choose to select an attribute that is not in the one of the grouping
attributes, then it chooses a random value

*there may be students who have not applied to any colleges, and they will not be 
represented in the results because they will not be in the result of the join

SELECT Student.sID, COUNT(DISTINCT cName)
FROM Student, Apply
WHERE Student.sID = Apply.sID 
GROUP BY Student.sID
UNION
SELECT sID, 0                   /*students that have not applied to any colleges will return 0
FROM Student
WHERE Student.sID NOT IN (SELECT sID FROM Apply);


e.g. HAVING clause - only used in conjunction with aggregation
*HAVING clause allows us to apply conditions to the results of aggregate functions
HAVING clause is entire group
WHERE applies to one tuple at a time

Find colleges with fewer than 5 applications

SELECT cName
FROM Apply
GROUP BY cName
HAVING COUNT(*) < 5;

*can write without having and group by clause

SELECT DISTINCT cName
FROM Apply A1       /*looking at each application record
WHERE 5 > (SELECT COUNT(*) FROM Apply A2 WHERE A2.cName = A1.cName); /*check number of other application to same college and count them and see if the number is less than 5

*can re-write every GROUP BY and HAVING without using them

e.g. Fewer than 5 applicants (not application) - instead of counting the # of apply
tuples for each college, count # of distinct student ID that appear in the group of apply tuple for that college

SELECT cName
FROM Apply
GROUP BY cName
HAVING COUNT (DISTINCT sID) < 5;

*Cornell has at least 5 applications but fewer than 5 applicants.... 


e.g. Find all majors represented in the DB where the applicant's max GPA is below the average

SELECT major
FROM Student, Apply
WHERE Student.sID = Apply.sID
GROUP BY major     /*look at major one at a time
HAVING MAX (GPA) < (SELECT AVG(GPA) FROM Student);

bioengineering and psychology has applicants whose highest GPA is lower than the average GPA


----------------
NULL values





